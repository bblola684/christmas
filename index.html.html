<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæ‰‹åŠ¿äº¤äº’åœ£è¯ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: -apple-system, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        
        /* UI æ ·å¼ */
        .controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 100;
            display: flex; flex-direction: column; gap: 10px;
            background: rgba(255, 255, 255, 0.1); padding: 15px;
            border-radius: 15px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);
        }
        .controls h3 { color: white; margin: 0 0 10px 0; font-size: 14px; }
        .btn-group { display: flex; gap: 10px; }
        button, label {
            padding: 8px 15px; background: white; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold; font-size: 12px; transition: 0.3s;
        }
        button:hover { background: #00ffcc; }
        #video-container {
            position: absolute; top: 20px; right: 20px; width: 160px; height: 120px;
            border-radius: 10px; overflow: hidden; border: 2px solid #00ffcc; transform: scaleX(-1);
            display: none; /* åˆå§‹éšè—ï¼Œè·å–æƒé™åæ˜¾ç¤º */
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        .hint {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.5); pointer-events: none; text-align: center;
            font-size: 14px;
        }
        #fullscreen-btn { position: absolute; top: 20px; left: 20px; z-index: 101; }
        .error-hint {
            color: #ff4444;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            font-size: 12px;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 8px;
        }
    </style>
</head>
<body>

<div id="root"></div>

<!-- æ‰‹åŠ¿è¯†åˆ«æ‘„åƒå¤´åé¦ˆ -->
<div id="video-container">
    <video id="webcam" autoplay playsinline muted></video>
</div>

<div class="hint" id="loading-hint">æ­£åœ¨åˆå§‹åŒ– AI æ‘„åƒå¤´...</div>
<div class="error-hint" id="error-hint" style="display: none;"></div>

<!-- UI ç•Œé¢ -->
<div class="controls">
    <h3>åœ£è¯å›¾ç‰‡ä»“åº“</h3>
    <div class="btn-group">
        <label for="img-upload">æ·»åŠ ç…§ç‰‡/æ–‡æ¡£</label>
        <input type="file" id="img-upload" multiple accept="image/*" style="display:none">
        <button id="fullscreen-btn-el">å…¨å±æ§åˆ¶</button>
    </div>
    <div style="color: #00ffcc; font-size: 11px; margin-top: 5px;">
        ğŸ‘Œ æåˆ: æŠ“å– | âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ–ï¸ å¼ å¼€: æ•£å¼€æ—‹è½¬
    </div>
</div>

<!-- ä¾èµ–åº“ Importmap -->
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.92.7"
  }
}
</script>

<!-- å¼•å…¥ MediaPipe æ‰‹åŠ¿åº“ -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1646424915/camera_utils.min.js"></script>

<script type="module">
import React, { useState, useMemo, useRef, useEffect, Suspense } from 'react';
import { createRoot } from 'react-dom';
import * as THREE from 'three';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { OrbitControls, Environment, Float, Text, ContactShadows, MeshReflectorMaterial } from '@react-three/drei';

// --- å…¨å±€æ‰‹åŠ¿çŠ¶æ€ ---
let handState = { gesture: 'open', x: 0, y: 0, pinch: false, scale: 1 };

// --- é”™è¯¯å¤„ç†å‡½æ•° ---
const showError = (message) => {
    const el = document.getElementById('error-hint');
    el.textContent = message;
    el.style.display = 'block';
    setTimeout(() => {
        el.style.display = 'none';
    }, 5000);
};

// --- åˆå§‹åŒ– MediaPipe ---
async function initAI() {
    try {
        const videoElement = document.getElementById('webcam');
        const loadingHint = document.getElementById('loading-hint');
        const videoContainer = document.getElementById('video-container');

        // æ£€æŸ¥æ‘„åƒå¤´æƒé™
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ï¼Œè¯·ä½¿ç”¨Chrome/Firefoxæœ€æ–°ç‰ˆæœ¬');
        }

        // åˆå§‹åŒ–Hands
        const hands = new window.Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // é™ä½æ¨¡å‹å¤æ‚åº¦æå‡å…¼å®¹æ€§
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            loadingHint.style.display = 'none';
            videoContainer.style.display = 'block';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // åˆ¤å®šé€»è¾‘
                const thumbTip = lm[4];
                const indexTip = lm[8];
                const middleTip = lm[12];
                
                // 1. æåˆåˆ¤æ–­ (æ‹‡æŒ‡é£ŸæŒ‡è·ç¦»)
                const distPinch = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                handState.pinch = distPinch < 0.05;

                // 2. æ¡æ‹³åˆ¤æ–­ (ä¸­æŒ‡æŒ‡å°–æ˜¯å¦ä½äºæŒ‡æ ¹)
                const isFist = middleTip.y > lm[9].y;
                handState.gesture = isFist ? 'fist' : 'open';

                // 3. åæ ‡æ˜ å°„ (åè½¬X)
                handState.x = (0.5 - indexTip.x) * 40;
                handState.y = (0.5 - indexTip.y) * 40;
                
                // 4. ç¼©æ”¾æ§åˆ¶ (æ ¹æ®æ‰‹éƒ¨æ•´ä½“é«˜åº¦)
                handState.scale = Math.max(0.5, Math.min(2.0, 1.0 + (lm[0].y - lm[12].y)));
            }
        });

        // åˆå§‹åŒ–æ‘„åƒå¤´
        const camera = new window.Camera(videoElement, {
            onFrame: async () => { 
                try {
                    await hands.send({ image: videoElement }); 
                } catch (e) {
                    console.warn('æ‘„åƒå¤´å¸§å¤„ç†é”™è¯¯:', e);
                }
            },
            width: 640,
            height: 480
        });
        
        await camera.start();
        
    } catch (error) {
        console.error('AIåˆå§‹åŒ–å¤±è´¥:', error);
        showError('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥: ' + error.message);
        document.getElementById('loading-hint').textContent = 'åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·å…è®¸æ‘„åƒå¤´æƒé™æˆ–åˆ·æ–°é¡µé¢';
    }
}

// --- ç²’å­ä¸å›¾ç‰‡æ··åˆç»„ä»¶ ---
const ParticleSystem = ({ images }) => {
    const count = 1500;
    const { viewport } = useThree();
    const dummy = useRef(new THREE.Object3D()); // ä½¿ç”¨useRefé¿å…é‡å¤åˆ›å»º
    const [selectedImg, setSelectedImg] = useState(null);

    // ç”Ÿæˆç²’å­åŸºç¡€æ•°æ®
    const particles = useMemo(() => {
        const temp = [];
        for (let i = 0; i < count; i++) {
            const t = i / count;
            const angle = i * 137.5 * (Math.PI / 180);
            
            // æ ‘å½¢ç›®æ ‡åæ ‡
            const r = (1 - t) * 10;
            const wave = Math.sin(t * 30) * 0.5;
            const treePos = new THREE.Vector3(Math.cos(angle) * (r + wave), t * 25 - 10, Math.sin(angle) * (r + wave));
            
            // éšæœºæ•£å¼€åæ ‡
            const randPos = new THREE.Vector3((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
            
            // å½¢çŠ¶ä¸é¢œè‰²
            const type = Math.floor(Math.random() * 5); // 0:çƒ, 1:æ–¹å—, 2:é”¥...
            const color = new THREE.Color(['#ff0000', '#00ff00', '#ffd700', '#ffffff', '#00ffff'][type]);
            
            temp.push({ 
                treePos, 
                randPos, 
                currPos: randPos.clone(), 
                color, 
                type, 
                scale: 0.3 + Math.random() * 0.4 
            });
        }
        return temp;
    }, []);

    // æ¯ä¸€å¸§çš„é€»è¾‘æ›´æ–°
    const meshRef = useRef();
    useFrame((state) => {
        if (!meshRef.current) return;
        
        const time = state.clock.getElapsedTime();
        const isFist = handState.gesture === 'fist';
        const isPinch = handState.pinch;

        particles.forEach((p, i) => {
            let target = isFist ? p.treePos : p.randPos;
            
            // æ—‹è½¬é€»è¾‘ï¼šå¦‚æœæ˜¯æ•£å¼€çŠ¶æ€ï¼Œç¼“æ…¢æ—‹è½¬
            if (!isFist) {
                const rotSpeed = 0.5;
                const ox = p.randPos.x;
                const oz = p.randPos.z;
                target.x = ox * Math.cos(time * rotSpeed) - oz * Math.sin(time * rotSpeed);
                target.z = ox * Math.sin(time * rotSpeed) + oz * Math.cos(time * rotSpeed);
            }

            // å¹³æ»‘æ’å€¼
            p.currPos.lerp(target, 0.05);
            
            // æ›´æ–°å®ä¾‹çŸ©é˜µ
            dummy.current.position.copy(p.currPos);
            dummy.current.scale.setScalar(p.scale * handState.scale);
            dummy.current.rotation.set(time * 0.5, time * 0.3, 0);
            dummy.current.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.current.matrix);
        });
        
        meshRef.current.instanceMatrix.needsUpdate = true;

        // æåˆæŠ“å–åˆ¤å®š
        if (isPinch && images.length > 0 && !selectedImg) {
            setSelectedImg(images[Math.floor(Math.random() * images.length)]);
        } else if (!isPinch && selectedImg) {
            setSelectedImg(null);
        }
    });

    // ä¸ºä¸åŒç²’å­ç±»å‹åˆ›å»ºå‡ ä½•ä½“
    const getGeometry = () => {
        // ç®€åŒ–ï¼šç»Ÿä¸€ä½¿ç”¨çƒä½“æå‡æ€§èƒ½
        return <sphereGeometry args={[0.3, 8, 8]} />;
    };

    return (
        <group>
            {/* ç²’å­ä¸»ä½“ï¼šä½¿ç”¨å®ä¾‹åŒ–ç½‘æ ¼æå‡æ€§èƒ½ */}
            <instancedMesh ref={meshRef} args={[null, null, count]}>
                {getGeometry()}
                <meshStandardMaterial 
                    roughness={0} 
                    metalness={1} 
                    envMapIntensity={2}
                    vertexColors={true}
                />
            </instancedMesh>

            {/* é€‰ä¸­çš„ç…§ç‰‡å¼¹å‡ºåŠ¨æ•ˆ */}
            {selectedImg && (
                <Float speed={5} rotationIntensity={2} floatIntensity={2}>
                    <mesh position={[0, 0, 10]}>
                        <planeGeometry args={[8, 10]} />
                        <meshBasicMaterial 
                            map={selectedImg.texture} 
                            transparent 
                            opacity={0.9}
                            side={THREE.DoubleSide}
                        />
                        {/* ç…§ç‰‡å…‰æ™• */}
                        <pointLight color="#00ffcc" intensity={50} distance={20} />
                    </mesh>
                    <Text position={[0, -6, 10]} fontSize={0.5} color="white">
                        {selectedImg.name}
                    </Text>
                </Float>
            )}
        </group>
    );
};

// --- åŠ è½½æç¤ºç»„ä»¶ ---
const Loading = () => (
    <mesh position={[0, 0, 0]}>
        <Text fontSize={1} color="#00ffcc">
            åŠ è½½ä¸­...
        </Text>
    </mesh>
);

// --- ä¸»åº”ç”¨åœºæ™¯ ---
const App = () => {
    const [images, setImages] = useState([]);
    
    // å›¾ç‰‡ä¸Šä¼ å¤„ç†
    useEffect(() => {
        const loader = new THREE.TextureLoader();
        const upload = document.getElementById('img-upload');
        
        // å›¾ç‰‡ä¸Šä¼ äº‹ä»¶
        upload.addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                if (!file.type.startsWith('image/')) return;
                
                const url = URL.createObjectURL(file);
                loader.load(
                    url, 
                    (txt) => {
                        txt.needsUpdate = true;
                        txt.wrapS = THREE.ClampToEdgeWrapping;
                        txt.wrapT = THREE.ClampToEdgeWrapping;
                        setImages(prev => [...prev, { texture: txt, name: file.name }]);
                    },
                    (progress) => console.log(`åŠ è½½ ${file.name}: ${(progress.loaded/progress.total)*100}%`),
                    (error) => showError(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${file.name}`)
                );
            });
        });

        // å…¨å±é€»è¾‘
        document.getElementById('fullscreen-btn-el').onclick = () => {
            try {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(e => {
                        showError('å…¨å±è¯·æ±‚è¢«æ‹’ç»');
                    });
                } else {
                    document.exitFullscreen();
                }
            } catch (e) {
                showError('å…¨å±æ§åˆ¶å¤±è´¥: ' + e.message);
            }
        };

        // åˆå§‹åŒ–AI
        initAI();

        // æ¸…ç†å‡½æ•°
        return () => {
            upload.removeEventListener('change', () => {});
        };
    }, []);

    return (
        <Canvas shadows camera={{ position: [0, 5, 45], fov: 45 }}>
            <color attach="background" args={['#050505']} />
            
            {/* ç¯å¢ƒå…‰æ•ˆ */}
            <fog attach="fog" args={['#050505', 30, 100]} />
            <ambientLight intensity={0.5} />
            <spotLight 
                position={[0, 40, 0]} 
                angle={0.5} 
                penumbra={1} 
                intensity={100} 
                castShadow 
                shadow-mapSize-width={2048}
                shadow-mapSize-height={2048}
            />
            
            {/* æ ‘é¡¶ç¯æ³¡ç²’å­ */}
            <mesh position={[0, 15, 0]}>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial 
                    color="#fff" 
                    emissive="#ffd700" 
                    emissiveIntensity={10} 
                />
                <pointLight intensity={100} color="#ffd700" />
            </mesh>

            <Suspense fallback={<Loading />}>
                <ParticleSystem images={images} />
                <Environment preset="city" background={false} />
            </Suspense>

            {/* åœ°é¢åå°„ */}
            <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -12, 0]}>
                <planeGeometry args={[100, 100]} />
                <MeshReflectorMaterial
                    blur={[300, 100]}
                    resolution={1024}
                    mixBlur={1}
                    mixStrength={60}
                    roughness={1}
                    depthScale={1.2}
                    minDepthThreshold={0.4}
                    maxDepthThreshold={1.4}
                    color="#151515"
                    metalness={0.5}
                />
            </mesh>
            
            <OrbitControls 
                makeDefault 
                enablePan={false} 
                maxPolarAngle={Math.PI / 2}
                enableZoom={true}
                minDistance={20}
                maxDistance={80}
            />
        </Canvas>
    );
};

// --- ç¡®ä¿DOMåŠ è½½å®Œæˆåæ¸²æŸ“ ---
document.addEventListener('DOMContentLoaded', () => {
    try {
        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    } catch (error) {
        console.error('Reactæ¸²æŸ“å¤±è´¥:', error);
        showError('åº”ç”¨åˆå§‹åŒ–å¤±è´¥: ' + error.message);
    }
});
</script>
</body>
</html>